{"ts":1357594526325,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"\n/*!\n * Stylus - Node\n * Copyright(c) 2010 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Evaluator = require('../visitor/evaluator')\n  , utils = require('../utils')\n  , nodes = require('./');\n\n/**\n * Node constructor.\n *\n * @api public\n */\n\nvar Node = module.exports = function Node(){\n  this.lineno = nodes.lineno;\n  Object.defineProperty(this, 'filename', { writable: true, value: nodes.filename });\n};\n\n/**\n * Return this node.\n *\n * @return {Node}\n * @api public\n */\n\nNode.prototype.__defineGetter__('first', function(){\n  return this;\n});\n\n/**\n * Return hash.\n *\n * @return {String}\n * @api public\n */\n\nNode.prototype.__defineGetter__('hash', function(){\n  return this.val;\n});\n\n/**\n * Return node name.\n *\n * @return {String}\n * @api public\n */\n\nNode.prototype.__defineGetter__('nodeName', function(){\n  return this.constructor.name.toLowerCase();\n});\n\n/**\n * Return this node.\n * \n * @return {Node}\n * @api public\n */\n\nNode.prototype.clone = function(){\n  return this;\n};\n\n/**\n * Nodes by default evaluate to themselves.\n *\n * @return {Node}\n * @api public\n */\n\nNode.prototype.eval = function(){\n  return new Evaluator(this).evaluate();\n};\n\n/**\n * Return true.\n *\n * @return {Boolean}\n * @api public\n */\n\nNode.prototype.toBoolean = function(){\n  return nodes.true;\n};\n\n/**\n * Return the expression, or wrap this node in an expression.\n *\n * @return {Expression}\n * @api public\n */\n\nNode.prototype.toExpression = function(){\n  if ('expression' == this.nodeName) return this;\n  var expr = new nodes.Expression;\n  expr.push(this);\n  return expr;\n};\n\n/**\n * Return false if `op` is generally not coerced.\n *\n * @param {String} op\n * @return {Boolean}\n * @api private\n */\n\nNode.prototype.shouldCoerce = function(op){\n  switch (op) {\n    case 'is a':\n    case 'in':\n    case '||':\n    case '&&':\n      return false;\n    default:\n      return true;\n  }\n};\n\n/**\n * Operate on `right` with the given `op`.\n *\n * @param {String} op\n * @param {Node} right\n * @return {Node}\n * @api public\n */\n\nNode.prototype.operate = function(op, right){\n  switch (op) {\n    case 'is a':\n      if ('string' == right.nodeName) {\n        return nodes.Boolean(this.nodeName == right.val);\n      } else {\n        throw new Error('\"is a\" expects a string, got ' + right.toString());\n      }\n    case '==':\n      return nodes.Boolean(this.hash == right.hash);\n    case '!=':\n      return nodes.Boolean(this.hash != right.hash);\n    case '>=':\n      return nodes.Boolean(this.hash >= right.hash);\n    case '<=':\n      return nodes.Boolean(this.hash <= right.hash);\n    case '>':\n      return nodes.Boolean(this.hash > right.hash);\n    case '<':\n      return nodes.Boolean(this.hash < right.hash);\n    case '||':\n      return this.toBoolean().isTrue\n        ? this\n        : right;\n    case 'in':\n      var vals = utils.unwrap(right).nodes\n        , hash = this.hash;\n      if (!vals) throw new Error('\"in\" given invalid right-hand operand, expecting an expression');\n      for (var i = 0, len = vals.length; i < len; ++i) {\n        if (hash == vals[i].hash) {\n          return nodes.true;\n        }\n      }\n      return nodes.false;\n    case '&&':\n      var a = this.toBoolean()\n        , b = right.toBoolean();\n      return a.isTrue && b.isTrue\n        ? right\n        : a.isFalse\n          ? this\n          : right;\n    default:\n      if ('[]' == op) {\n        var msg = 'cannot perform '\n          + this\n          + '[' + right + ']';\n      } else {\n        var msg = 'cannot perform'\n          + ' ' + this\n          + ' ' + op\n          + ' ' + right;\n      }\n      throw new Error(msg);\n  }\n};\n\n/**\n * Initialize a new `CoercionError` with the given `msg`.\n *\n * @param {String} msg\n * @api private\n */\n\nfunction CoercionError(msg) {\n  this.name = 'CoercionError'\n  this.message = msg\n  Error.captureStackTrace(this, CoercionError);\n}\n\n/**\n * Inherit from `Error.prototype`.\n */\n\nCoercionError.prototype.__proto__ = Error.prototype;\n\n/**\n * Default coercion throws.\n *\n * @param {Node} other\n * @return {Node}\n * @api public\n */\n\nNode.prototype.coerce = function(other){\n  if (other.nodeName == this.nodeName) return other;\n  throw new CoercionError('cannot coerce ' + other + ' to ' + this.nodeName);\n};\n"]],"start1":0,"start2":0,"length1":0,"length2":4230}]],"length":4230}
